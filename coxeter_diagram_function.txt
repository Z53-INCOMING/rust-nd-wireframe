fn generate_polytope_from_coxeter_diagram(vertices: &mut Vec<Vector4<f32>>, edges: &mut Vec<usize>, coxeter_edges: &Vec<u8>, coxeter_rings: &Vec<bool>) {
    let mut angles: Vec<f32> = Vec::new();
    
    for weight in coxeter_edges {
        // every angle is an nth of a half turn
        angles.push(TAU / ((*weight * 2) as f32));
    }
    
    let mut pre_matrix: Matrix4<f32> = Matrix4::identity();
    
    let rank = coxeter_edges.len() + 1;
    
    for i in 0..rank {
        for j in 0..rank {
            if i != j { // preserve diagonal
                if i8::abs((i as i8) - (j as i8)) == 1 { // if the nodes are right next to each other, there's an edge connecting them
                    pre_matrix[i * 4 + j] = f32::cos(angles[usize::min(i, j)]);
                } // otherwise, the weight is 2, and cosine of 90 degrees is 0, and it's already 0
            }
        }
    }
    
    let mirror_matrix: Matrix4<f32> = pre_matrix.cholesky().expect("invalid coxeter diagram").unpack().transpose();
    
    let mut point: Vector4<f32> = Vector4::new(0.0, 0.0, 0.0, 0.0);
    
    // thanks buzz for the wedge product
    let fundamental_simplex = Matrix4::from_fn(|r, c| {
            (-1f32).powi(r as i32) * mirror_matrix.remove_row(r).remove_column(c).determinant()
        }
    );
    
    let mut ringed_node_count = 0;
    for i in 0..rank {
        if coxeter_rings[i] {
            point += fundamental_simplex.column(i);
            ringed_node_count += 1;
        }
    }
    point /= ringed_node_count as f32;
    point = point.normalize();
    
    for i in 0..2048 {
        vertices.push(point);
        
        let mirror_index= (rand() % rank as u32) as usize;
        
        point += -point.dot(&mirror_matrix.column(mirror_index)) * mirror_matrix.column(mirror_index) * 2.0;
    }
}
